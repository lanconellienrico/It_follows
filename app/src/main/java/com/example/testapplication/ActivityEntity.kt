package com.example.testapplication

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.room.Entity
import androidx.room.PrimaryKey
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.time.LocalDateTime
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter

/**
 * ActivityEntity defines an activity by:
 * - type (walking, running, ...)
 * - start/stop time
 * - steps (if it's a step-able activity)
 * - id (for Db - autogenerated)
 */
@Entity(tableName = "Activity")
@RequiresApi(Build.VERSION_CODES.O)
data class ActivityEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,                                      // auto-generated Id

    val activityType: String,                             // type of activity
    val startTime: Long = System.currentTimeMillis(),     // create activity = start activity
    var stopTime: Long = 0L,                              // activity's over = stop time
    var steps: Int = 0                                    // walking/running have steps to count
) {

    // does time really exists? maybe it's the way you look at it

    // save stop time and insert into Db
    fun stopActivity(dao: ActivityDao){
        stopTime = System.currentTimeMillis()

        // add to Db
        CoroutineScope(Dispatchers.IO).launch{
            dao.insert(this@ActivityEntity)
        }
    }

    // formatting activity in a fashion styled String, in order to be displayed
    fun toPrint(): String{
        val text = ("${activityType.uppercase()}\n" +
                " started: ${prettyTime(startTime)},\n" +
                " stopped: ${prettyTime(stopTime)},\n" +
                " duration: ${giveMeDuration(startTime, stopTime)}" +
                (steps.takeIf { it != 0}?.let {",\n$it steps taken" } ?: ""))
        return text
    }

    // make time readable
    private fun prettyTime(t: Long): String {
        val tConverted = LocalDateTime.ofEpochSecond(t/1000, 0, ZoneOffset.ofHours(0))
        val formatted = tConverted.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"))
        return formatted
    }

    // handle duration to show it in a readable way
    private fun giveMeDuration(t0: Long, t1: Long): String{
        var result = ""
        val hour = 3600
        val min = 60
        var deltaT = (t1-t0)/1000 // duration in sec
        /* TEST
        deltaT += 240
        deltaT += 4000
        */
        if(deltaT > hour) {     // calc. hours
            val hoursCount = (deltaT/hour).toInt()
            deltaT -= hour*hoursCount
            result = "$hoursCount hour, "
        }
        if(deltaT > min) {     // calc. minutes
            val minCount = (deltaT/min).toInt()
            deltaT -= min*minCount
            result += "$minCount min, "
        }
        result += "$deltaT s"    // add seconds

        return result
    }
}